<div class="col-md-12 text-center">
    <h4>SOME TECHNICAL NOTES</h4>
</div>

<div class="col-md-12 text-justify">
    <b>What is this about?</b> This server accepts the description of a <i>regular
    language</i> via a finite automaton and the description of a language <i>property</i>, and returns YES/NO, depending on whether the
    language satisfies the property. In case the answer is NO, appropriate counterexamples (also called witness words) are provided. If the language satisfies the property, the server can also return YES/NO, depending on whether the language is maximal with respect to the property. The Maximality question is PSPACE-hard. In the case of the Construction question [10], I-LaSer accepts the description of  a property and three positive integers s, N, k, and generates a language of (up to) N words of length k satisfying the given property. The integer s must be less than 10 and specifies that the alphabet must be {'0','1',...,'s'}. See further below how to describe properties.
</div>

<div class="col-md-12 text-justify">
    <br>
    <b>Online computation</b> VS <b>Program generation: </b> When a user specifies a 
    question to solve and the required input, ILaSer  either computes the answer in real time, if the user clicks on "Submit Request", or it produces a zip file containing a self contained Python2.7 executable file, if the user clicks on "Generate Program". In the latter case, the executable file can produce the answer on the user's local machine.
    <!-- by, either dragging it into the user's python.exe icon, or by entering 'python fname.zip' on a command line window, where fname.zip is the name of the downloaded executable file.  -->
    <br>
    <b>Limits on online computations:</b> Depending on the sizes of the given automaton and transducer,
    the underlying software could perform a great deal of processing before it returns
    an answer. For this reason, the following limits on processing requests are
    enforced.
    <ul>
    <li>
    Requests for the Satisfaction question are not processed, if the quantity N*N*M exceeds 500,000, where N and M are the numbers of transitions in the automaton and
    transducer, respectively.  
    </li><li>
    Requests for the Construction question are not processed, if the quantity N*N*L*M exceeds 500,000, where N is the requested number of words, L is the requested length of these words, and M is, either the number of transitions in the 
    transducer describing the property, or M=1 if the property is fixed.
    </li>
    </ul>
</div>

<div class="col-md-12 text-justify">
    <br>
    <b>Properties</b> Examples of language properties are: prefix code, infix code, 1-substitution-error-detecting language [6,5,3]. These are examples of <i>independences</i> (independent properties). Roughly speaking, a language satisfies an independence if every subset of the language also satisfies that independence. Many independent properties have the following characteristic: a language L satisfies the property P if there are NO different words u,v in L such that v can result by performing a certain word <u>operation</u> on u--this word operation is what defines the property P. For example, prefix codes are defined by the word operation of removing any nonempty ending of the word u; and 1-substitution-detecting languages are defined by the operation that changes exactly 1 symbol in the word u. Certain transducers can conveniently be used to realize such operations, and we say that each such transducer <u>describes</u> a property.  The method of trajectories is more limited in describing independences, but the descriptions are much simpler.
    I-LaSer supports the following independent properties.  
    </p>
    <ul>
        <div class="col-md-12 text-justify" style="margin-bottom: 5px;">
            <li><u>Fixed properties</u> These are (uniquely decipherable/decodable) code, prefix code, suffix code, infix code, outfix code, hypercode.
            </li>
        </div>

        <div class="col-md-12 text-justify" style="margin-bottom: 5px;">
            <li><u>Regular trajectory properties [2]</u>
                A regular expression <i>e</i> over {0, 1} describes the following property.
                All languages <i>L</i> in
                which no two words are related as expressed in <i>e</i>. In particular,
                when the zeros in <i>e</i> represent
                positions of a word v in  <i>L</i>, then there can be no other word in <i>L</i>
                containg v as expressed in <i>e</i>.
                For example, 0*1* describes the <i>prefix code</i> property, since a prefix code
                cannot have a word u containing another word v as a prefix (v as 0* and u as 0*1*).
                Similarly, 1*0* describes the <i>suffix code</i> property.
            </li>
        </div>

        <div class="col-md-12 text-justify" style="margin-bottom: 5px;">
            <li>
                <u>Input-altering Transducer properties [1]</u> 
                A <u>transducer</u> <i>t</i> is a 
                nondeterministic automaton with output such that <i>t(w)</i> = the set of possible output words of <i>t</i> when the input is the word <i>w</i>. Note that <i>t(w)</i> could be empty for some words <i>w</i>. An input-altering transducer is one such that, for any input word <i>w</i>,  the output is never equal to <i>w</i>.
                An input-altering transducer <i>t</i> <u>describes</u> the following property.
                All languages <i>L</i>  such that
                <code>
                    t(L) &cap; L = EmptySet
                </code>
                that is, the transducer <i>t</i> cannot take as input an <i>L</i>-word and also output an <i>L</i>-word. For example, the <i>prefix code</i> property can be
                described via a transducer that, on input w, returns all <i>proper</i> prefixes
                of w---see <b>Format
                for transducers</b> for more details. 
            </li>
        </div>

        <div class="col-md-12 text-justify" style="margin-bottom: 5px;">
            <li>
                <u>Error-detecting properties [1,9]</u> Such a property is described by
                an input-preserving transducer <i>t</i> as follows.
                All languages <i>L</i>  such that
                <code>
                    y in t(x) implies y=x,
                </code>
                for any words <code>x, y in L</code>; that is, on any input word x from <i>L</i>, the
                transducer <i>t</i> will never output another word in <i>L</i>.
                An <u>input-preserving transducer</u>, also called <u>channel</u>, is a transducer t 
                that, on any input word w for which t(w) is nonempty, the set t(w) includes w; thus, t acts as a communication channel that receives a word w and can always return w (case of no error) or posiibly a word other than w (case of error). For example, the <i>1-subsitution-detection</i> property can be
                described by a transducer that, on input w, returns either w or any word that obtains by changing 1 symbol of w---see <b>Format
                for transducers</b> for examples.  
            </li>
        </div>

        <div class="col-md-12 text-justify" style="margin-bottom: 5px;">
            <li>
                <u>Error-correcting properties [9]</u> Such a property is described by
                an input-preserving transducer <i>t</i>  as follows.
                All languages <i>L</i>  such that
                <code>
                    w in t(x) and w in t(y) implies y=x,
                </code>
                for any words <code>x, y in L</code> and any word w; that is, the transducer cannot turn two different input words x, y from <i>L</i> into the same word. For example, the <i>1-subsitution-correction</i> property can be
                described by a transducer that, on input w, returns either w or any word that obtains by changing 1 symbol of w.  
            </li>
        </div>

     </ul>

    <br>
    <b>Implementation: </b> Based on <a href="http://fado.dcc.fc.up.pt/">FAdo</a>, a set of Python libraries, which includes modules for automata, transducers,
    and code properties.

</div>

<div class="col-md-12 text-center"><h4> <b>Some References</b></h4>
</div>
<div class="col-md-12 text-justify">
    [1] K. Dudzinski and S. Konstantinidis.
    <a href="http://cs.smu.ca/~stavros/papers/submit-final-DuKo.pdf">
        Formal descriptions of code properties:</a> decidability, complexity, implementation. International Journal of Foundations of Computer Science 23:1 (2012), 67--85. Presented at <a href="http://www.cs.usask.ca/dcfs2010/">DCFS 2010</a>.
    <br>
    [2] M. Domaratzki.
    Trajectory-Based Codes. Acta Informatica, vol. 40, n. 6-7 (2004) 491-527.
    <br>
    [3] H. Jurgensen and S. Konstantinidis. Codes:
    In G. Rozenberg, A. Salomaa (eds): Handbook of Formal Languages, vol. I,
    511-607. Springer-Verlag, Berlin, 1997.
    <br>
    [4] Jurgen Dassow. Comment following the presentation in [1].
    <br>
    [5] H.J. Shyr.
    Free monoids and languages. Hon Min Book Company, Taichung, Taiwan, 1991.
    <br>
    [6] H.J. Shyr and G. Thierrin.
    Codes and binary relations. Seminaire d'Algebre Paul Dubreil, Paris 1975--1976
    (29\`eme Ann\'ee), Lecture Notes in Mathematics, 586, 1977, 180--188.
    <br>
    [7] <a href="http://fado.dcc.fc.up.pt/">FAdo: Tools for Formal Languages
    manipulation</a>.
    <br>
    [8] Andre Almeida, Marco Almeida, Jose Alves, Nelma Moreira, and Rogerio Reis.
    Fado and guitar: tools for automata manipulation and visualization.
    In S. Maneth, editor, CIAA 2009: Fourteenth International Conference on
    Implementation and Application of Automata, volume 5642 of Lecture Notes on
    Computer Science, pages 65-74, Sydney, Australia, July 2009. Springer-Verlag.
    <br>
    [9] Konstantinidis S, Meijer C, Moreira N, Reis R. (2016). Implementation of Code Properties via Transducers. Lecture Notes in Computer Science 9705. 21st International Conference on the Implementation and Application of Automata (CIAA 2016), Seoul, Korea, Republic of (189-201). ArXiv version: Symbolic manipulation of code properties. arXiv:1504.04715v1, 2015
    <br>
    [10] Konstantinidis S, Moreira N, Reis R. (2016). Generating Error Control Codes with Automata and Transducers. OCG Proceedings. 8th Workshop on Non-Classical Models of Automata and Applications, Debrecen, Hungary.
</div>